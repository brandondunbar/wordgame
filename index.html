<!DOCTYPE html>
<html lang="en">
<script src="firebase-config.js"></script>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Chain - Multiplayer Word Game</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; }
    </style>

    <!-- Firebase SDKs - Modular -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, getDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        
        // Set Firestore log level to debug for better console output
        setLogLevel('Debug');
        
        // Ensure global variables are available for the React component
        window.firebaseDependencies = {
            initializeApp,
            getAuth,
            signInAnonymously,
            signInWithCustomToken,
            onAuthStateChanged,
            getFirestore,
            doc,
            setDoc,
            onSnapshot,
            getDoc
        };
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // ============================================
        // GLOBAL VARIABLES (Provided by Canvas Environment)
        // ============================================
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'wordchain-default-app';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Destructure dependencies loaded via the module script
        const {
            initializeApp, getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged,
            getFirestore, doc, setDoc, onSnapshot, getDoc
        } = window.firebaseDependencies || {};

        // Lucide React icons as inline SVG components
        const Users = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path>
                <circle cx="9" cy="7" r="4"></circle>
                <path d="M22 21v-2a4 4 0 0 0-3-3.87"></path>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
            </svg>
        );

        const Plus = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
        );

        const Clock = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12 6 12 12 16 14"></polyline>
            </svg>
        );

        const Heart = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} className={className} viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
            </svg>
        );

        // Game constants
        const TIMER_DURATION = 10;
        const STARTING_LIVES = 3;
        const WORDS_FILE_PATH = './words.txt'; // Relative path to be fetched on GitHub Pages
        const LETTER_COMBOS = [
          'th', 'ch', 'sh', 'st', 'br', 'gr', 'tr', 'pl', 'fl', 'cl',
          'qu', 'ph', 'wh', 'cr', 'pr', 'fr', 'dr', 'sp', 'sm', 'sn',
          'sc', 'sk', 'sl', 'sw', 'tw', 'bl', 'gl', 'ing', 'tion', 'ous'
        ];

        function WordChainGame() {
          const [screen, setScreen] = useState('menu');
          const [roomCode, setRoomCode] = useState('');
          const [playerName, setPlayerName] = useState('');
          const [currentRoom, setCurrentRoom] = useState(null);
          const [gameState, setGameState] = useState(null);
          const [input, setInput] = useState('');
          const [timer, setTimer] = useState(TIMER_DURATION);
          const [error, setError] = useState('');
          const [validWords, setValidWords] = useState(new Set());
          const [loadingWords, setLoadingWords] = useState(true);
          
          // Firebase States
          const [db, setDb] = useState(null);
          const [auth, setAuth] = useState(null);
          const [userId, setUserId] = useState(null);
          const [isAuthReady, setIsAuthReady] = useState(false);

          const timerRef = useRef(null);
          const roomUnsubscribeRef = useRef(null);
          const gameUnsubscribeRef = useRef(null);

          // ----------------------------------------------------
          // 1. FIREBASE INITIALIZATION & AUTHENTICATION
          // ----------------------------------------------------
          useEffect(() => {
              if (!initializeApp || !firebaseConfig) {
                  setError('Firebase dependencies not loaded.');
                  return;
              }

              try {
                  const app = initializeApp(firebaseConfig);
                  const firestore = getFirestore(app);
                  const userAuth = getAuth(app);
                  setDb(firestore);
                  setAuth(userAuth);
                  console.log('Firebase initialized.');

                  // Authentication Logic
                  const authenticate = async () => {
                      if (initialAuthToken) {
                          await signInWithCustomToken(userAuth, initialAuthToken);
                      } else {
                          await signInAnonymously(userAuth);
                      }
                  };

                  onAuthStateChanged(userAuth, (user) => {
                      if (user) {
                          setUserId(user.uid);
                          console.log('User signed in with UID:', user.uid);
                      } else {
                          // This case should be rare if token is provided, but handles anonymous sign-in fallback.
                          setUserId(crypto.randomUUID()); 
                          console.log('User signed anonymously or needs sign-in.');
                      }
                      setIsAuthReady(true);
                  });

                  // Execute sign-in promise chain
                  authenticate().catch(e => {
                      console.error('Authentication Error:', e);
                      setError(`Authentication failed: ${e.message}`);
                      setIsAuthReady(true);
                  });

              } catch (e) {
                  console.error('Firebase Setup Error:', e);
                  setError(`Firebase setup failed: ${e.message}`);
              }
          }, []); // Run only once

          // ----------------------------------------------------
          // 2. DATA UTILITIES (Firestore References)
          // ----------------------------------------------------
          const getRoomDocRef = useCallback((code) => {
              if (!db) return null;
              const roomCodeUpper = code.toUpperCase();
              return doc(db,
                "artifacts", appId,
                "public", "data",
                "rooms", roomCodeUpper
              );

          }, [db, appId]);

          const getGameDocRef = useCallback((code) => {
              if (!db) return null;
              const roomCodeUpper = code.toUpperCase();
              return doc(db,
                "artifacts", appId,
                "public", "data",
                "rooms", roomCodeUpper
              );

          }, [db, appId]);


          // ----------------------------------------------------
          // 3. WORD LIST LOADING
          // ----------------------------------------------------
          useEffect(() => {
            const loadWordList = async () => {
              try {
                const response = await fetch(WORDS_FILE_PATH);
                if (!response.ok) {
                    throw new Error(`Failed to fetch ${WORDS_FILE_PATH}. Status: ${response.status}`);
                }
                const text = await response.text();
                const words = text.split('\n').map(w => w.trim().toLowerCase()).filter(w => w.length > 0);
                setValidWords(new Set(words));
                console.log(`Loaded ${words.length} words for validation.`);
              } catch (err) {
                console.error('Failed to load word list:', err);
                setError('Failed to load word list. Validation may not work.');
              } finally {
                setLoadingWords(false);
              }
            };
            loadWordList();
          }, []);

          // ----------------------------------------------------
          // 4. ROOM/GAME LISTENERS
          // ----------------------------------------------------
          const startListening = useCallback((code) => {
            if (!db || !isAuthReady) return;

            // Cleanup existing listeners
            if (roomUnsubscribeRef.current) roomUnsubscribeRef.current();
            if (gameUnsubscribeRef.current) gameUnsubscribeRef.current();

            // Room Listener
            const roomRef = getRoomDocRef(code);
            roomUnsubscribeRef.current = onSnapshot(roomRef, (docSnap) => {
                const room = docSnap.data();
                if (room) {
                    setCurrentRoom(room);
                    if (room.status === 'finished') {
                        setScreen('results');
                    }
                } else {
                    // Room deleted or no longer exists
                    setCurrentRoom(null);
                    setScreen('menu');
                    setError('Room was closed by the host.');
                    if (gameUnsubscribeRef.current) gameUnsubscribeRef.current();
                }
            }, (err) => {
                console.error("Room Snapshot Error:", err);
                setError("Realtime room error.");
            });

            // Game Listener
            const gameRef = getGameDocRef(code);
            gameUnsubscribeRef.current = onSnapshot(gameRef, (docSnap) => {
                const game = docSnap.data();
                if (game) {
                    setGameState(game);
                    if (currentRoom && currentRoom.status === 'playing') {
                        setScreen('game');
                    }
                }
            }, (err) => {
                console.error("Game Snapshot Error:", err);
            });
          }, [db, isAuthReady, appId, currentRoom]);


          // ----------------------------------------------------
          // 5. GAME ACTIONS
          // ----------------------------------------------------
          const generateRoomCode = () => {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
          };

          const createRoom = async () => {
            if (!db || !isAuthReady) { setError('System not ready.'); return; }
            if (!playerName.trim()) { setError('Please enter your name'); return; }
            
            // Generate a unique code
            let code;
            let roomExists = true;
            // Loop until a non-existent code is generated (unlikely to loop more than once)
            while (roomExists) {
                code = generateRoomCode();
                const docSnap = await getDoc(getRoomDocRef(code));
                roomExists = docSnap.exists();
            }

            const room = {
              code,
              host: playerName,
              players: [{ name: playerName, lives: STARTING_LIVES, active: true, id: userId }],
              status: 'waiting',
              createdAt: Date.now()
            };

            try {
              await setDoc(getRoomDocRef(code), room);
              setRoomCode(code);
              setCurrentRoom(room);
              setScreen('lobby');
              startListening(code);
              setError('');
            } catch (err) {
              console.error('Create room error:', err);
              setError(`Failed to create room: ${err.message}`);
            }
          };

          const joinRoom = async () => {
            if (!db || !isAuthReady) { setError('System not ready.'); return; }
            if (!playerName.trim()) { setError('Please enter your name'); return; }
            if (!roomCode.trim()) { setError('Please enter room code'); return; }
            
            const code = roomCode.toUpperCase();
            
            try {
              const docSnap = await getDoc(getRoomDocRef(code));
              
              if (!docSnap.exists()) {
                setError('Room not found');
                return;
              }

              const room = docSnap.data();
              
              if (room.status !== 'waiting') {
                setError('Game already in progress');
                return;
              }

              if (room.players.some(p => p.name === playerName)) {
                setError('Name already taken in this room');
                return;
              }
              
              if (room.players.some(p => p.id === userId)) {
                setError('You are already in this room as another player.');
                return;
              }

              const updatedPlayers = [...room.players, { name: playerName, lives: STARTING_LIVES, active: true, id: userId }];
              const updatedRoom = { ...room, players: updatedPlayers };

              await setDoc(getRoomDocRef(code), updatedRoom);
              
              setCurrentRoom(updatedRoom);
              setScreen('lobby');
              startListening(code);
              setError('');
            } catch (err) {
              console.error('Join room error:', err);
              setError(`Failed to join room: ${err.message}`);
            }
          };

          const startGame = async () => {
            if (!currentRoom || currentRoom.host !== playerName || currentRoom.players.length < 2) return;
            if (!db) return;

            const game = {
              currentPlayerIndex: 0,
              currentPrompt: LETTER_COMBOS[Math.floor(Math.random() * LETTER_COMBOS.length)],
              usedWords: [],
              turnStartTime: Date.now()
            };

            const updatedRoom = { ...currentRoom, status: 'playing' };

            try {
              await setDoc(getRoomDocRef(currentRoom.code), updatedRoom);
              await setDoc(getGameDocRef(currentRoom.code), game);
              setScreen('game');
            } catch (err) {
              console.error('Start game error:', err);
              setError('Failed to start game');
            }
          };

          const loseLife = async (playerIndex = gameState.currentPlayerIndex) => {
            if (!db || !currentRoom) return;
            
            // Update local room state first
            const updatedPlayers = [...currentRoom.players];
            const currentPlayer = updatedPlayers[playerIndex];
            currentPlayer.lives -= 1;
            
            if (currentPlayer.lives <= 0) {
              currentPlayer.active = false;
            }

            const activePlayers = updatedPlayers.filter(p => p.active);
            
            if (activePlayers.length <= 1) {
              // Game Over
              const updatedRoom = { ...currentRoom, players: updatedPlayers, status: 'finished' };
              await setDoc(getRoomDocRef(currentRoom.code), updatedRoom);
            } else {
              // Only update room and trigger next turn
              const updatedRoom = { ...currentRoom, players: updatedPlayers };
              await setDoc(getRoomDocRef(currentRoom.code), updatedRoom);
              await nextTurn();
            }
          };

          const nextTurn = async (validWord = null) => {
            if (!db || !gameState || !currentRoom) return;

            const usedWords = validWord ? [...gameState.usedWords, validWord] : gameState.usedWords;
            
            let nextIndex = (gameState.currentPlayerIndex + 1) % currentRoom.players.length;
            
            // Loop to find the next active player
            let attempts = 0;
            while (!currentRoom.players[nextIndex].active && attempts < currentRoom.players.length) {
              nextIndex = (nextIndex + 1) % currentRoom.players.length;
              attempts++;
            }
            
            // Check if only one active player remains (game should have ended, but as a safeguard)
            if (attempts >= currentRoom.players.length) {
                // If we looped through everyone and didn't find an active player, force game over
                const updatedRoom = { ...currentRoom, status: 'finished' };
                await setDoc(getRoomDocRef(currentRoom.code), updatedRoom);
                return;
            }

            const newGame = {
              currentPlayerIndex: nextIndex,
              currentPrompt: LETTER_COMBOS[Math.floor(Math.random() * LETTER_COMBOS.length)],
              usedWords,
              turnStartTime: Date.now()
            };

            await setDoc(getGameDocRef(currentRoom.code), newGame);
            setTimer(TIMER_DURATION); // Reset local timer state
          };

          const submitWord = async () => {
            if (!input.trim() || !gameState || !currentRoom || !db) return;

            const currentPlayer = currentRoom.players.find(p => p.id === userId);
            const isMyTurn = currentRoom.players[gameState.currentPlayerIndex].id === userId;

            if (!currentPlayer || !isMyTurn) {
                setError('It is not your turn.');
                return;
            }

            const word = input.trim().toLowerCase();
            
            if (!validWords.has(word)) {
              setError('ðŸš« Not a valid word!');
              await loseLife();
              return;
            }

            if (!word.includes(gameState.currentPrompt.toLowerCase())) {
              setError(`ðŸ’¡ Word must contain "${gameState.currentPrompt.toUpperCase()}"!`);
              await loseLife();
              return;
            }

            if (gameState.usedWords.includes(word)) {
              setError('â™»ï¸ Word already used!');
              await loseLife();
              return;
            }

            // Word is valid
            setError('');
            setInput('');
            await nextTurn(word);
          };

          // ----------------------------------------------------
          // 6. TIMER LOGIC
          // ----------------------------------------------------
          useEffect(() => {
            if (screen === 'game' && gameState && currentRoom) {
              const currentPlayer = currentRoom.players[gameState.currentPlayerIndex];
              const isMyTurn = currentPlayer.id === userId;
              
              if (isMyTurn) {
                if (timerRef.current) clearInterval(timerRef.current);
                
                // Interval runs every 100ms for smooth UI update
                timerRef.current = setInterval(() => {
                  const elapsed = Math.floor((Date.now() - gameState.turnStartTime) / 1000);
                  const remaining = TIMER_DURATION - elapsed;
                  
                  if (remaining <= 0) {
                    clearInterval(timerRef.current);
                    setError('ðŸš¨ Time up! You lose a life.');
                    loseLife(); // Use default loseLife which targets current player
                  } else {
                    setTimer(remaining);
                  }
                }, 100);
              } else {
                  // If it's not my turn, just update the timer once to sync the elapsed time from Firestore.
                  const elapsed = Math.floor((Date.now() - gameState.turnStartTime) / 1000);
                  setTimer(Math.max(0, TIMER_DURATION - elapsed));
                  if (timerRef.current) clearInterval(timerRef.current); // Stop my timer
              }
            }

            return () => {
              if (timerRef.current) clearInterval(timerRef.current);
            };
          }, [screen, gameState, currentRoom, userId, loseLife]);
          
          // Cleanup on unmount
          useEffect(() => {
            return () => {
              if (timerRef.current) clearInterval(timerRef.current);
              if (roomUnsubscribeRef.current) roomUnsubscribeRef.current();
              if (gameUnsubscribeRef.current) gameUnsubscribeRef.current();
            };
          }, []);


          // ----------------------------------------------------
          // 7. UI RENDERING
          // ----------------------------------------------------
          if (!isAuthReady || loadingWords) {
            return (
              <div className="min-h-screen bg-gradient-to-br from-purple-600 to-blue-600 flex items-center justify-center p-4">
                <div className="bg-white rounded-2xl shadow-2xl p-8 text-center">
                  <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-600 mx-auto mb-4"></div>
                  <p className="text-gray-700">Initializing & Loading Assets...</p>
                </div>
              </div>
            );
          }

          if (screen === 'menu') {
            return (
              <div className="min-h-screen bg-gradient-to-br from-purple-600 to-blue-600 flex items-center justify-center p-4">
                <div className="bg-white rounded-2xl shadow-2xl p-8 w-full max-w-md">
                  <h1 className="text-4xl font-bold text-center mb-2 text-gray-800">Word Chain</h1>
                  <p className="text-center text-gray-600 mb-6">Fast-paced word game</p>
                  
                  {userId && (
                    <p className="text-xs text-gray-500 text-center mb-4 truncate" title={userId}>
                        Your User ID: {userId}
                    </p>
                  )}
                  
                  <input
                    type="text"
                    placeholder="Your name"
                    value={playerName}
                    onChange={(e) => setPlayerName(e.target.value)}
                    className="w-full px-4 py-3 border-2 border-gray-300 rounded-lg mb-4 focus:border-purple-500 focus:outline-none"
                  />
                  
                  {error && <p className="text-red-500 text-sm mb-4 text-center">{error}</p>}
                  
                  <button
                    onClick={createRoom}
                    className="w-full bg-purple-600 text-white py-3 rounded-lg font-semibold mb-3 hover:bg-purple-700 transition flex items-center justify-center gap-2 shadow-md hover:shadow-lg"
                  >
                    <Plus size={20} />
                    Create Room
                  </button>
                  
                  <div className="flex gap-2">
                    <input
                      type="text"
                      placeholder="Room code"
                      value={roomCode}
                      onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
                      className="flex-1 px-4 py-3 border-2 border-gray-300 rounded-lg focus:border-purple-500 focus:outline-none uppercase"
                      maxLength="6"
                    />
                    <button
                      onClick={joinRoom}
                      className="bg-blue-600 text-white px-6 py-3 rounded-lg font-semibold hover:bg-blue-700 transition shadow-md hover:shadow-lg"
                    >
                      Join
                    </button>
                  </div>
                  
                  <p className="text-center text-sm text-gray-500 mt-4">
                    {validWords.size.toLocaleString()} words loaded
                  </p>
                </div>
              </div>
            );
          }

          if (screen === 'lobby' && currentRoom) {
            const isHost = currentRoom.host === playerName;
            return (
              <div className="min-h-screen bg-gradient-to-br from-purple-600 to-blue-600 flex items-center justify-center p-4">
                <div className="bg-white rounded-2xl shadow-2xl p-8 w-full max-w-md">
                  <h2 className="text-3xl font-bold text-center mb-2 text-gray-800">Lobby</h2>
                  <p className="text-center text-2xl font-mono font-extrabold bg-yellow-100 text-purple-700 p-2 rounded-lg mb-6 shadow-inner">
                    {currentRoom.code}
                  </p>
                  
                  {error && <p className="text-red-500 text-sm mb-4 text-center">{error}</p>}

                  <div className="bg-gray-50 rounded-lg p-4 mb-6 shadow-inner">
                    <div className="flex items-center gap-2 mb-3 border-b pb-2">
                      <Users size={20} className="text-purple-600" />
                      <h3 className="font-semibold text-gray-700">Players ({currentRoom.players.length})</h3>
                    </div>
                    <div className="space-y-2 max-h-48 overflow-y-auto">
                      {currentRoom.players.map((player, i) => (
                        <div key={i} className="flex items-center gap-2 p-1">
                          <div className={`w-3 h-3 rounded-full ${player.active ? 'bg-green-500' : 'bg-red-500'}`}></div>
                          <span className="text-gray-800 font-medium">{player.name}</span>
                          {player.name === currentRoom.host && (
                            <span className="text-xs bg-purple-200 text-purple-800 px-2 py-0.5 rounded-full font-bold">HOST</span>
                          )}
                        </div>
                      ))}
                    </div>
                  </div>
                  
                  {isHost ? (
                    <button
                      onClick={startGame}
                      disabled={currentRoom.players.length < 2}
                      className="w-full bg-green-600 text-white py-3 rounded-lg font-semibold hover:bg-green-700 transition disabled:bg-gray-400 disabled:cursor-not-allowed shadow-xl hover:shadow-2xl"
                    >
                      {currentRoom.players.length < 2 ? 'Waiting for players (min 2)...' : 'Start Game'}
                    </button>
                  ) : (
                    <p className="text-center text-gray-600 bg-blue-100 p-3 rounded-lg">Waiting for host to start the game...</p>
                  )}
                </div>
              </div>
            );
          }

          if (screen === 'game' && gameState && currentRoom) {
            const currentPlayer = currentRoom.players[gameState.currentPlayerIndex];
            const isMyTurn = currentPlayer.id === userId;

            return (
              <div className="min-h-screen bg-gradient-to-br from-purple-600 to-blue-600 flex items-center justify-center p-4">
                <div className="bg-white rounded-2xl shadow-2xl p-8 w-full max-w-2xl">
                  <div className="flex justify-between items-start mb-6 border-b pb-4">
                    <div>
                      <h2 className="text-2xl font-bold text-gray-800 mb-1">Room: {currentRoom.code}</h2>
                      <p className="text-gray-600 text-sm">Playing against {currentRoom.players.length - 1} others</p>
                    </div>
                    
                    <div className="text-right">
                       <p className="text-sm font-semibold text-gray-500">
                        {isMyTurn ? 'Your Turn' : `${currentPlayer.name}'s Turn`}
                       </p>
                      <div className={`flex items-center gap-2 text-3xl font-extrabold mt-1 ${isMyTurn ? 'text-red-600 animate-pulse' : 'text-gray-700'}`}>
                        <Clock className="w-6 h-6" />
                        <span>{timer}s</span>
                      </div>
                    </div>
                  </div>

                  <div className="grid grid-cols-2 md:grid-cols-4 gap-3 mb-6">
                    {currentRoom.players.map((player, i) => (
                      <div
                        key={i}
                        className={`p-3 rounded-xl border-2 transition-all duration-300 shadow-sm ${
                          i === gameState.currentPlayerIndex
                            ? 'bg-purple-100 border-purple-500 shadow-lg scale-105'
                            : 'bg-gray-50 border-gray-200'
                        } ${!player.active && 'opacity-50 grayscale'}`}
                      >
                        <div className="font-bold text-gray-800 truncate" title={player.name}>
                            {player.name}
                        </div>
                        <div className="flex gap-1 mt-1">
                          {[...Array(STARTING_LIVES)].map((_, j) => (
                            <Heart 
                              key={j} 
                              size={16} 
                              className={`transition-all duration-300 ${j < player.lives ? 'fill-red-500 text-red-500' : 'fill-gray-300 text-gray-300'}`} 
                            />
                          ))}
                        </div>
                        {!player.active && <span className="text-xs text-red-600 font-semibold">OUT!</span>}
                      </div>
                    ))}
                  </div>

                  <div className="bg-gradient-to-r from-purple-700 to-blue-700 rounded-xl p-8 mb-6 text-center shadow-inner">
                    <p className="text-white text-sm mb-2 font-semibold">YOUR PROMPT:</p>
                    <p className="text-white text-7xl font-black tracking-widest">
                      {gameState.currentPrompt.toUpperCase()}
                    </p>
                  </div>

                  {isMyTurn ? (
                    <div>
                      <input
                        type="text"
                        value={input}
                        onChange={(e) => setInput(e.target.value)}
                        onKeyPress={(e) => e.key === 'Enter' && submitWord()}
                        placeholder="Type your word here..."
                        className="w-full px-4 py-3 border-2 border-purple-400 rounded-xl mb-3 focus:ring-4 focus:ring-purple-200 focus:outline-none text-xl font-medium"
                        autoFocus
                      />
                      {error && <p className="text-red-600 text-sm mb-3 text-center font-semibold bg-red-50 p-2 rounded">{error}</p>}
                      <button
                        onClick={submitWord}
                        className="w-full bg-green-500 text-white py-3 rounded-xl font-semibold text-lg hover:bg-green-600 transition shadow-lg hover:shadow-xl"
                      >
                        SUBMIT WORD
                      </button>
                    </div>
                  ) : (
                    <div className="text-center py-8 bg-blue-50 rounded-xl border border-blue-200">
                      <p className="text-xl text-gray-600">
                        Waiting for <span className="font-bold text-blue-600">{currentPlayer.name}</span> to submit a word...
                      </p>
                    </div>
                  )}

                  {gameState.usedWords.length > 0 && (
                    <div className="mt-6 pt-6 border-t border-gray-200">
                      <p className="text-sm text-gray-600 mb-2 font-semibold">Recently Used Words:</p>
                      <div className="flex flex-wrap gap-2 max-h-24 overflow-y-auto">
                        {gameState.usedWords.slice(-15).reverse().map((word, i) => (
                          <span key={i} className="bg-gray-100 px-3 py-1 rounded-full text-xs text-gray-700 shadow-sm">
                            {word}
                          </span>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              </div>
            );
          }

          if (screen === 'results' && currentRoom) {
            const winner = currentRoom.players.find(p => p.active);
            const sortedPlayers = [...currentRoom.players].sort((a, b) => {
              // Winner first (active=true)
              if (a.active && !b.active) return -1;
              if (!a.active && b.active) return 1;
              // Then by lives remaining
              return b.lives - a.lives;
            });

            const handleReturnToMenu = () => {
                setScreen('menu');
                setCurrentRoom(null);
                setGameState(null);
                setRoomCode('');
                setError('');
                // The onSnapshot listeners automatically clean up, but we call the refs for good measure
                if (roomUnsubscribeRef.current) roomUnsubscribeRef.current();
                if (gameUnsubscribeRef.current) gameUnsubscribeRef.current();
            };

            return (
              <div className="min-h-screen bg-gradient-to-br from-purple-600 to-blue-600 flex items-center justify-center p-4">
                <div className="bg-white rounded-2xl shadow-2xl p-8 w-full max-w-md">
                  <h2 className="text-3xl font-black text-center mb-2 text-gray-800">GAME OVER!</h2>
                  
                  {winner ? (
                    <div className="text-center mb-6 p-4 bg-yellow-100 rounded-xl border-4 border-yellow-500 shadow-lg">
                        <p className="text-5xl mb-2">ðŸ‘‘</p>
                        <p className="text-2xl font-bold text-gray-800">Winner: {winner.name}</p>
                        <p className="text-sm text-gray-600">Congratulations!</p>
                    </div>
                  ) : (
                    <div className="text-center mb-6 p-4 bg-red-100 rounded-xl border-4 border-red-500 shadow-lg">
                        <p className="text-2xl font-bold text-gray-800">Everyone was eliminated!</p>
                    </div>
                  )}

                  <div className="space-y-3 mb-6">
                    {sortedPlayers.map((player, i) => (
                      <div
                        key={i}
                        className={`p-4 rounded-xl flex justify-between items-center transition-all ${
                          i === 0 && winner ? 'bg-yellow-200 border-2 border-yellow-500' : 'bg-gray-100'
                        }`}
                      >
                        <div>
                          <div className="font-bold text-gray-800">
                            {i === 0 && winner ? 'ðŸ¥‡ ' : i === 1 ? 'ðŸ¥ˆ ' : i === 2 ? 'ðŸ¥‰ ' : ''}
                            {player.name}
                          </div>
                          <div className="text-sm text-gray-600">
                            {player.active ? `${player.lives} lives remaining` : 'Eliminated'}
                          </div>
                        </div>
                        <div className="text-2xl font-bold text-gray-700">#{i + 1}</div>
                      </div>
                    ))}
                  </div>
                  
                  <button
                    onClick={handleReturnToMenu}
                    className="w-full bg-purple-600 text-white py-3 rounded-xl font-semibold hover:bg-purple-700 transition shadow-lg hover:shadow-xl"
                  >
                    Play Again
                  </button>
                </div>
              </div>
            );
          }

          return null;
        }

        ReactDOM.render(<WordChainGame />, document.getElementById('root'));
    </script>
</body>
</html>